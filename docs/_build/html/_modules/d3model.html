

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>d3model &mdash; CSLVR  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> CSLVR
          

          
          </a>

          
            
            
              <div class="version">
                2017
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Preliminaries</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../get_started.html">Hello CSLVR</a></li>
</ul>
<p class="caption"><span class="caption-text">Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../input.html">Input</a></li>
<li class="toctree-l1"><a class="reference internal" href="../output.html">Output</a></li>
</ul>
<p class="caption"><span class="caption-text">Mesh generation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../meshing.html">Meshing</a></li>
</ul>
<p class="caption"><span class="caption-text">Base Classes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../model.html">The Model classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../physics.html">The Physics classes</a></li>
</ul>
<p class="caption"><span class="caption-text">Balance equations</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../momentum.html">Momentum balance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mass.html">Mass balance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../energy.html">Energy balance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../velocity.html">Velocity balance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../stress.html">Stress balance</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CSLVR</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>d3model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for d3model</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">dolfin</span>            <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">dolfin_adjoint</span>    <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">cslvr.inputoutput</span> <span class="k">import</span> <span class="n">print_text</span><span class="p">,</span> <span class="n">get_text</span><span class="p">,</span> <span class="n">print_min_max</span>
<span class="kn">from</span> <span class="nn">cslvr.model</span>       <span class="k">import</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">cslvr.helper</span>      <span class="k">import</span> <span class="n">Boundary</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span>     <span class="k">import</span> <span class="n">cKDTree</span>
<span class="kn">from</span> <span class="nn">copy</span>              <span class="k">import</span> <span class="n">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span>               <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>   <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>

<div class="viewcode-block" id="D3Model"><a class="viewcode-back" href="../model.html#d3model.D3Model">[docs]</a><span class="k">class</span> <span class="nc">D3Model</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot; </span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">OMEGA_GND</span>   <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># internal cells over bedrock</span>
  <span class="n">OMEGA_FLT</span>   <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># internal cells over water</span>
  <span class="n">GAMMA_S_GND</span> <span class="o">=</span> <span class="mi">2</span>   <span class="c1"># grounded upper surface</span>
  <span class="n">GAMMA_B_GND</span> <span class="o">=</span> <span class="mi">3</span>   <span class="c1"># grounded lower surface (bedrock)</span>
  <span class="n">GAMMA_S_FLT</span> <span class="o">=</span> <span class="mi">6</span>   <span class="c1"># shelf upper surface</span>
  <span class="n">GAMMA_B_FLT</span> <span class="o">=</span> <span class="mi">5</span>   <span class="c1"># shelf lower surface</span>
  <span class="n">GAMMA_L_DVD</span> <span class="o">=</span> <span class="mi">7</span>   <span class="c1"># basin divides</span>
  <span class="n">GAMMA_L_OVR</span> <span class="o">=</span> <span class="mi">4</span>   <span class="c1"># terminus over water</span>
  <span class="n">GAMMA_L_UDR</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># terminus under water</span>
  <span class="n">GAMMA_U_GND</span> <span class="o">=</span> <span class="mi">8</span>   <span class="c1"># grounded surface with U observations</span>
  <span class="n">GAMMA_U_FLT</span> <span class="o">=</span> <span class="mi">9</span>   <span class="c1"># shelf surface with U observations</span>
  <span class="n">GAMMA_ACC</span>   <span class="o">=</span> <span class="mi">1</span>   <span class="c1"># areas with positive surface accumulation</span>

  <span class="c1"># external boundaries :</span>
  <span class="n">ext_boundaries</span> <span class="o">=</span> <span class="p">{</span><span class="n">GAMMA_S_GND</span> <span class="p">:</span> <span class="s1">&#39;grounded upper surface&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_B_GND</span> <span class="p">:</span> <span class="s1">&#39;grounded lower surface (bedrock)&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_S_FLT</span> <span class="p">:</span> <span class="s1">&#39;shelf upper surface&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_B_FLT</span> <span class="p">:</span> <span class="s1">&#39;shelf lower surface&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_L_DVD</span> <span class="p">:</span> <span class="s1">&#39;basin divides&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_L_OVR</span> <span class="p">:</span> <span class="s1">&#39;terminus over water&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_L_UDR</span> <span class="p">:</span> <span class="s1">&#39;terminus under water&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_U_GND</span> <span class="p">:</span> <span class="s1">&#39;grounded upper surface with U observations&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_U_FLT</span> <span class="p">:</span> <span class="s1">&#39;shelf upper surface with U observations&#39;</span><span class="p">,</span>
                    <span class="n">GAMMA_ACC</span>   <span class="p">:</span> <span class="s1">&#39;upper surface with accumulation&#39;</span><span class="p">}</span>

  <span class="c1"># internal boundaries :</span>
  <span class="n">int_boundaries</span> <span class="o">=</span> <span class="p">{</span><span class="n">OMEGA_GND</span>   <span class="p">:</span> <span class="s1">&#39;internal cells located over bedrock&#39;</span><span class="p">,</span>
                    <span class="n">OMEGA_FLT</span>   <span class="p">:</span> <span class="s1">&#39;internal cells located over water&#39;</span><span class="p">}</span>

  <span class="c1"># union :</span>
  <span class="n">boundaries</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;OMEGA&#39;</span> <span class="p">:</span> <span class="n">int_boundaries</span><span class="p">,</span>
                <span class="s1">&#39;GAMMA&#39;</span> <span class="p">:</span> <span class="n">ext_boundaries</span><span class="p">}</span>

  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="s1">&#39;./results/&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
               <span class="n">use_periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A three-dimensional model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: INITIALIZING 3D MODEL :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="n">Model</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">out_dir</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">use_periodic</span><span class="p">)</span>
  
<div class="viewcode-block" id="D3Model.color"><a class="viewcode-back" href="../model.html#d3model.D3Model.color">[docs]</a>  <span class="k">def</span> <span class="nf">color</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;130&#39;</span></div>

<div class="viewcode-block" id="D3Model.generate_pbc"><a class="viewcode-back" href="../model.html#d3model.D3Model.generate_pbc">[docs]</a>  <span class="k">def</span> <span class="nf">generate_pbc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return a SubDomain of periodic lateral boundaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - using 3D periodic boundaries -&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">xmin</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">MPI</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    
    <span class="k">class</span> <span class="nc">PeriodicBoundary</span><span class="p">(</span><span class="n">SubDomain</span><span class="p">):</span>
      
      <span class="k">def</span> <span class="nf">inside</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return True if on left or bottom boundary AND NOT on one </span>
<span class="sd">        of the two corners (0, 1) and (1, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">((</span><span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">or</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymin</span><span class="p">))</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="p">((</span><span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymax</span><span class="p">))</span> \
                     <span class="ow">or</span> <span class="p">(</span><span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmax</span><span class="p">)</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymin</span><span class="p">))))</span> \
                     <span class="ow">and</span> <span class="n">on_boundary</span><span class="p">)</span>

      <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remap the values on the top and right sides to the bottom and left</span>
<span class="sd">        sides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmax</span><span class="p">)</span> <span class="ow">and</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymax</span><span class="p">):</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xmax</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ymax</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xmax</span><span class="p">):</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xmax</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymax</span><span class="p">):</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ymax</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">pBC</span> <span class="o">=</span> <span class="n">PeriodicBoundary</span><span class="p">()</span></div>
  
<div class="viewcode-block" id="D3Model.set_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the mesh.</span>
<span class="sd">    </span>
<span class="sd">    :param mesh : Dolfin mesh to be written</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">D3Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting 3D mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt; 3D MODEL REQUIRES A 3D MESH, EXITING &lt;&lt;&lt;&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">num_facets</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_facets</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">num_cells</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_cells</span><span class="p">()</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">()</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - </span><span class="si">%i</span><span class="s2">D mesh set, </span><span class="si">%i</span><span class="s2"> cells, </span><span class="si">%i</span><span class="s2"> facets, </span><span class="si">%i</span><span class="s2"> vertices - &quot;</span> \
        <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_facets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span><span class="p">)</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>
  
<div class="viewcode-block" id="D3Model.set_flat_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_flat_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_flat_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flat_mesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sets the flat_mesh for 3D free-surface.</span>
<span class="sd">    </span>
<span class="sd">    :param flat_mesh : Dolfin mesh to be written</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting 3D ``flat&#39;&#39; mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">flat_mesh</span> <span class="o">=</span> <span class="n">flat_mesh</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flat_dim</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">()</span><span class="o">.</span><span class="n">topological_dimension</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat_dim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt; 3D MODEL REQUIRES A 3D FLAT_MESH, EXITING &lt;&lt;&lt;&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.set_srf_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_srf_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_srf_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">srfmesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the surface boundary mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting surface boundary mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">srfmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">HDF5File</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">srfmesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
      <span class="n">srfmesh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">srfmesh</span><span class="p">,</span> <span class="s1">&#39;srfmesh&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">srfmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">srfmesh</span> <span class="o">=</span> <span class="n">srfmesh</span></div>

<div class="viewcode-block" id="D3Model.set_bed_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_bed_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_bed_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bedmesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the basal boundary mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting basal boundary mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bedmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">HDF5File</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">bedmesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
      <span class="n">bedmesh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bedmesh</span><span class="p">,</span> <span class="s1">&#39;bedmesh&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bedmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">bedmesh</span> <span class="o">=</span> <span class="n">bedmesh</span></div>

<div class="viewcode-block" id="D3Model.set_lat_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_lat_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_lat_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">latmesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the lateral boundary mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting lateral boundary mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">HDF5File</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
      <span class="n">latmesh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span><span class="p">,</span> <span class="s1">&#39;latmesh&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">latmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span> <span class="o">=</span> <span class="n">latmesh</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">Q_lat</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.set_dvd_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_dvd_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">set_dvd_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dvdmesh</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the lateral divide boundary mesh.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: setting lateral divide boundary mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dvdmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">HDF5File</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
      <span class="n">dvdmesh</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span><span class="p">,</span> <span class="s1">&#39;dvdmesh&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dvdmesh</span><span class="p">,</span> <span class="n">dolfin</span><span class="o">.</span><span class="n">cpp</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">Mesh</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span> <span class="o">=</span> <span class="n">dvdmesh</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">Q_dvd</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.form_srf_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.form_srf_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">form_srf_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sets self.srfmesh, the surface boundary mesh for this model instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: extracting surface mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">bmesh</span>   <span class="o">=</span> <span class="n">BoundaryMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;exterior&#39;</span><span class="p">)</span>
    <span class="n">cellmap</span> <span class="o">=</span> <span class="n">bmesh</span><span class="o">.</span><span class="n">entity_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pb</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">bmesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">bmesh</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">Facet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">()])</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">SubMesh</span><span class="p">(</span><span class="n">bmesh</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">srfmesh</span> <span class="o">=</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="D3Model.form_bed_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.form_bed_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">form_bed_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sets self.bedmesh, the basal boundary mesh for this model instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: extracting bed mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">bmesh</span>   <span class="o">=</span> <span class="n">BoundaryMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;exterior&#39;</span><span class="p">)</span>
    <span class="n">cellmap</span> <span class="o">=</span> <span class="n">bmesh</span><span class="o">.</span><span class="n">entity_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pb</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">bmesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">bmesh</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">Facet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">()])</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">1e-3</span><span class="p">:</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">SubMesh</span><span class="p">(</span><span class="n">bmesh</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">bedmesh</span> <span class="o">=</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="D3Model.form_lat_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.form_lat_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">form_lat_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sets self.latmesh, the lateral boundary mesh for this model instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: extracting lateral mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">bmesh</span>   <span class="o">=</span> <span class="n">BoundaryMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;exterior&#39;</span><span class="p">)</span>
    <span class="n">cellmap</span> <span class="o">=</span> <span class="n">bmesh</span><span class="o">.</span><span class="n">entity_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pb</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">bmesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">bmesh</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Facet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">()])</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">SubMesh</span><span class="p">(</span><span class="n">bmesh</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span> <span class="o">=</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="D3Model.form_dvd_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.form_dvd_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">form_dvd_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contour</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sets self.dvdmesh, the lateral divide boundary mesh for this model instance.</span>

<span class="sd">    :param contour: NumPy array of exterior points to exclude.</span>
<span class="sd">    :type contour:  :class:`numpy.ndarray`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: extracting lateral divide mesh :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
      
    <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>

    <span class="n">bmesh</span>   <span class="o">=</span> <span class="n">BoundaryMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;exterior&#39;</span><span class="p">)</span>
    <span class="n">cellmap</span> <span class="o">=</span> <span class="n">bmesh</span><span class="o">.</span><span class="n">entity_map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">pb</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s2">&quot;size_t&quot;</span><span class="p">,</span> <span class="n">bmesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="n">bmesh</span><span class="p">):</span>
      <span class="n">f</span>       <span class="o">=</span> <span class="n">Facet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">cellmap</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">index</span><span class="p">()])</span>
      <span class="n">n</span>       <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
      <span class="n">x_m</span>     <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">()</span>
      <span class="n">y_m</span>     <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="p">()</span>
      <span class="n">z_m</span>     <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">z</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-3</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
        <span class="n">pb</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">SubMesh</span><span class="p">(</span><span class="n">bmesh</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span> <span class="o">=</span> <span class="n">submesh</span></div>

<div class="viewcode-block" id="D3Model.generate_function_spaces"><a class="viewcode-back" href="../model.html#d3model.D3Model.generate_function_spaces">[docs]</a>  <span class="k">def</span> <span class="nf">generate_function_spaces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates the appropriate finite-element function spaces from parameters</span>
<span class="sd">    specified in the config file for the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">D3Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">generate_function_spaces</span><span class="p">()</span>

    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: generating 3D function spaces :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_periodic</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Q4</span>    <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">QM4e</span><span class="p">,</span>
                                 <span class="n">constrained_domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pBC</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">QTH3</span>  <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">QTH3e</span><span class="p">,</span>
                                 <span class="n">constrained_domain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pBC</span><span class="p">)</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - 3D function spaces created - &quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.generate_submesh_to_mesh_map"><a class="viewcode-back" href="../model.html#d3model.D3Model.generate_submesh_to_mesh_map">[docs]</a>  <span class="k">def</span> <span class="nf">generate_submesh_to_mesh_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_model</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a map from each of the functionspaces defined in this model with the</span>
<span class="sd">    submesh model ``sub_model``. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: for now, only works for linear elements.</span>
    
    <span class="n">bmesh</span>   <span class="o">=</span> <span class="n">BoundaryMesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;exterior&quot;</span><span class="p">)</span> <span class="c1"># surface boundary mesh</span>
    <span class="n">vertmap</span> <span class="o">=</span> <span class="n">bmesh</span><span class="o">.</span><span class="n">entity_map</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                 <span class="c1"># map from bmesh to mesh</span>
    <span class="n">submesh</span> <span class="o">=</span> <span class="n">sub_model</span><span class="o">.</span><span class="n">mesh</span>                      <span class="c1"># get the submesh</span>
    <span class="n">m</span>       <span class="o">=</span> <span class="n">vertex_to_dof_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">si</span>      <span class="o">=</span> <span class="n">dof_to_vertex_map</span><span class="p">(</span><span class="n">sub_model</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">t</span>       <span class="o">=</span> <span class="n">submesh</span><span class="o">.</span><span class="n">data</span><span class="p">()</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;parent_vertex_indices&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># form the map from submesh dof to mesh dof :</span>
    <span class="n">mesh_vertices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sub_dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sub_model</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">dim</span><span class="p">()):</span>
      <span class="n">submesh_vertex</span>     <span class="o">=</span> <span class="n">si</span><span class="p">[</span><span class="n">sub_dof</span><span class="p">]</span>
      <span class="n">boundary_vertex</span>    <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">submesh_vertex</span><span class="p">]</span>
      <span class="n">mesh_vertex</span>        <span class="o">=</span> <span class="n">vertmap</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">boundary_vertex</span><span class="p">)]</span> <span class="c1"># np.uint not accepted</span>
      <span class="n">mesh_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mesh_vertex</span><span class="p">)</span>
    <span class="n">Q_to_Qs_dofmap</span>       <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">mesh_vertices</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">submesh_map_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Q&#39;</span> <span class="p">:</span> <span class="n">Q_to_Qs_dofmap</span><span class="p">}</span></div>

<div class="viewcode-block" id="D3Model.assign_from_submesh_variable"><a class="viewcode-back" href="../model.html#d3model.D3Model.assign_from_submesh_variable">[docs]</a>  <span class="k">def</span> <span class="nf">assign_from_submesh_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_sub</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the values from the variable ``u_sub`` defined on a submesh of </span>
<span class="sd">    this :class:`~model.Model`&#39;s mesh to the variable ``u``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: only the upper surface, need lower surface too.</span>
    <span class="n">u_sub_a</span> <span class="o">=</span> <span class="n">u_sub</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">u_a</span>     <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">dofmap</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submesh_map_dict</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span>
    <span class="n">n</span>       <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">u_a</span><span class="p">[</span><span class="n">dofmap</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_sub_a</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">u_a</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">][</span><span class="n">dofmap</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_sub_a</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">u_a</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vert_extrude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="D3Model.assign_to_submesh_variable"><a class="viewcode-back" href="../model.html#d3model.D3Model.assign_to_submesh_variable">[docs]</a>  <span class="k">def</span> <span class="nf">assign_to_submesh_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">u_sub</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign the values from the variable ``u`` defined on a 3D mesh used</span>
<span class="sd">    with a :class:`~model.D3Model` to the submesh variable ``u_sub``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u_sub_a</span> <span class="o">=</span> <span class="n">u_sub</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">u_a</span>     <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">dofmap</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">submesh_map_dict</span><span class="p">[</span><span class="s1">&#39;Q&#39;</span><span class="p">]</span>
    <span class="n">n</span>       <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">u_sub_a</span> <span class="o">=</span> <span class="n">u_a</span><span class="p">[</span><span class="n">dofmap</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">u_sub_a</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_a</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">3</span><span class="p">][</span><span class="n">dofmap</span><span class="p">]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="n">u_sub</span><span class="p">,</span> <span class="n">u_sub_a</span><span class="p">)</span></div>


<div class="viewcode-block" id="D3Model.calculate_boundaries"><a class="viewcode-back" href="../model.html#d3model.D3Model.calculate_boundaries">[docs]</a>  <span class="k">def</span> <span class="nf">calculate_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">mask</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">adot</span>        <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">U_mask</span>      <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                           <span class="n">mark_divide</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                           <span class="n">contour</span>     <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the boundaries of the current model mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: calculating boundaries :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span>    <span class="p">(</span><span class="n">contour</span> <span class="ow">is</span>     <span class="kc">None</span> <span class="ow">and</span>     <span class="n">mark_divide</span><span class="p">)</span> \
       <span class="ow">or</span> <span class="p">(</span><span class="n">contour</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mark_divide</span><span class="p">):</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt; IF PARAMETER &lt;mark_divide&gt; OF calculate_boundaries() IS &quot;</span> <span class="o">+</span> \
          <span class="s2">&quot;TRUE, PARAMETER &lt;contour&gt; MUST BE A NUMPY ARRAY OF COORDINATES &quot;</span> <span class="o">+</span> \
          <span class="s2">&quot;OF THE ICE-SHEET EXTERIOR BOUNDARY &lt;&lt;&lt;&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">contour</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">mark_divide</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - marking the interior facets for incomplete meshes -&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
      <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">contour</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">contour_tree</span> <span class="o">=</span> <span class="n">tree</span> <span class="c1"># save this for ``self.form_dvd_mesh()``</span>
     
    <span class="c1"># this function contains markers which may be applied to facets of the mesh</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ff</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ff_acc</span>  <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cf</span>      <span class="o">=</span> <span class="n">MeshFunction</span><span class="p">(</span><span class="s1">&#39;size_t&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">dofmap</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">dofmap</span><span class="p">()</span>
    
    <span class="c1"># default to all grounded ice :</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">mask</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1.0&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
    
    <span class="c1"># default to zero accumulation :</span>
    <span class="k">if</span> <span class="n">adot</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">adot</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;0.0&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
   
    <span class="c1"># convert constants to expressions that can be evaluated at (x,y,z) :</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">adot</span><span class="p">)</span> <span class="o">==</span> <span class="n">Constant</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">adot</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">adot</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">adot</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;adot&#39;</span><span class="p">,</span> <span class="n">adot</span><span class="o">=</span><span class="n">adot</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># default to U observations everywhere :</span>
    <span class="k">if</span> <span class="n">U_mask</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">U_mask</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;1.0&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">init_adot</span><span class="p">(</span><span class="n">adot</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_U_mask</span><span class="p">(</span><span class="n">U_mask</span><span class="p">)</span>
    
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
    
    <span class="c1"># iterate through the facets and mark each if on a boundary :</span>
    <span class="c1">#</span>
    <span class="c1">#   2 = high slope, upward facing ................ grounded surface</span>
    <span class="c1">#   3 = grounded high slope, downward facing ..... grounded base</span>
    <span class="c1">#   4 = low slope, upward or downward facing ..... sides</span>
    <span class="c1">#   5 = floating ................................. floating base</span>
    <span class="c1">#   6 = floating ................................. floating surface</span>
    <span class="c1">#   7 = floating sides</span>
    <span class="c1">#</span>
    <span class="c1"># facet for accumulation :</span>
    <span class="c1">#</span>
    <span class="c1">#   1 = high slope, upward facing ................ positive adot</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - iterating through </span><span class="si">%i</span><span class="s2"> facets - &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_facets</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">facets</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
      <span class="n">n</span>        <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">normal</span><span class="p">()</span>
      <span class="n">x_m</span>      <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">()</span>
      <span class="n">y_m</span>      <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="p">()</span>
      <span class="n">z_m</span>      <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">()</span>
      <span class="n">mask_xy</span>  <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">,</span> <span class="n">z_m</span><span class="p">)</span>
      
      <span class="k">if</span>   <span class="n">n</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&gt;=</span>  <span class="n">tol</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">exterior</span><span class="p">():</span>
        <span class="n">adot_xy</span>   <span class="o">=</span> <span class="n">adot</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">,</span> <span class="n">z_m</span><span class="p">)</span>
        <span class="n">U_mask_xy</span> <span class="o">=</span> <span class="n">U_mask</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">,</span> <span class="n">z_m</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adot_xy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">ff_acc</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_ACC</span>
        <span class="k">if</span> <span class="n">mask_xy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">U_mask_xy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_FLT</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_FLT</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">U_mask_xy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_GND</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_GND</span>
    
      <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">exterior</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">mask_xy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_FLT</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_GND</span>
      
      <span class="k">elif</span> <span class="n">n</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&gt;</span>  <span class="o">-</span><span class="n">tol</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">z</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">exterior</span><span class="p">():</span>
        <span class="c1"># if we want to use a basin, we need to mark the interior facets :</span>
        <span class="k">if</span> <span class="n">mark_divide</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">((</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">z_m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_OVR</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_UDR</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_DVD</span>
        <span class="c1"># otherwise just mark for over (4) and under (10) water :</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">z_m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_OVR</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_UDR</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - done - &quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - iterating through </span><span class="si">%i</span><span class="s2"> cells - &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cells</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
      <span class="n">x_m</span>     <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">()</span>
      <span class="n">y_m</span>     <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">y</span><span class="p">()</span>
      <span class="n">z_m</span>     <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">midpoint</span><span class="p">()</span><span class="o">.</span><span class="n">z</span><span class="p">()</span>
      <span class="n">mask_xy</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="n">x_m</span><span class="p">,</span> <span class="n">y_m</span><span class="p">,</span> <span class="n">z_m</span><span class="p">)</span>

      <span class="k">if</span> <span class="n">mask_xy</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OMEGA_FLT</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cf</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">OMEGA_GND</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - done - &quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
  
    <span class="bp">self</span><span class="o">.</span><span class="n">set_measures</span><span class="p">()</span></div>

<div class="viewcode-block" id="D3Model.set_measures"><a class="viewcode-back" href="../model.html#d3model.D3Model.set_measures">[docs]</a>  <span class="k">def</span> <span class="nf">set_measures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    set the new measure space for facets ``self.ds`` and cells ``self.dx`` for</span>
<span class="sd">    the boundaries marked by FacetFunction ``self.ff`` and CellFunction </span>
<span class="sd">    ``self.cf``, respectively.</span>

<span class="sd">    Also, the number of facets marked by </span>
<span class="sd">    :func:`calculate_boundaries` :</span>

<span class="sd">    * ``self.N_OMEGA_GND``   -- number of cells marked ``self.OMEGA_GND``  </span>
<span class="sd">    * ``self.N_OMEGA_FLT``   -- number of cells marked ``self.OMEGA_FLT``  </span>
<span class="sd">    * ``self.N_GAMMA_S_GND`` -- number of facets marked ``self.GAMMA_S_GND``</span>
<span class="sd">    * ``self.N_GAMMA_B_GND`` -- number of facets marked ``self.GAMMA_B_GND``</span>
<span class="sd">    * ``self.N_GAMMA_S_FLT`` -- number of facets marked ``self.GAMMA_S_FLT``</span>
<span class="sd">    * ``self.N_GAMMA_B_FLT`` -- number of facets marked ``self.GAMMA_B_FLT``</span>
<span class="sd">    * ``self.N_GAMMA_L_DVD`` -- number of facets marked ``self.GAMMA_L_DVD``</span>
<span class="sd">    * ``self.N_GAMMA_L_OVR`` -- number of facets marked ``self.GAMMA_L_OVR``</span>
<span class="sd">    * ``self.N_GAMMA_L_UDR`` -- number of facets marked ``self.GAMMA_L_UDR``</span>
<span class="sd">    * ``self.N_GAMMA_U_GND`` -- number of facets marked ``self.GAMMA_U_GND``</span>
<span class="sd">    * ``self.N_GAMMA_U_FLT`` -- number of facets marked ``self.GAMMA_U_FLT``</span>

<span class="sd">    The subdomains corresponding to FacetFunction ``self.ff`` are :</span>

<span class="sd">    * ``self.dBed_g``  --  grounded bed</span>
<span class="sd">    * ``self.dBed_f``  --  floating bed</span>
<span class="sd">    * ``self.dBed``    --  bed</span>
<span class="sd">    * ``self.dSrf_gu`` --  grounded with U observations</span>
<span class="sd">    * ``self.dSrf_fu`` --  floating with U observations</span>
<span class="sd">    * ``self.dSrf_u``  --  surface with U observations</span>
<span class="sd">    * ``self.dSrf_g``  --  surface of grounded ice</span>
<span class="sd">    * ``self.dSrf_f``  --  surface of floating ice</span>
<span class="sd">    * ``self.dSrf``    --  surface</span>
<span class="sd">    * ``self.dLat_d``  --  lateral divide</span>
<span class="sd">    * ``self.dLat_to`` --  lateral terminus overwater</span>
<span class="sd">    * ``self.dLat_tu`` --  lateral terminus underwater</span>
<span class="sd">    * ``self.dLat_t``  --  lateral terminus</span>
<span class="sd">    * ``self.dLat``    --  lateral</span>

<span class="sd">    The subdomains corresponding to CellFunction ``self.cf`` are :</span>

<span class="sd">    * ``self.dx_g``    --  internal above grounded</span>
<span class="sd">    * ``self.dx_f``    --  internal above floating</span>

<span class="sd">    This method will create a :py:class:`dict` called ``self.measures``</span>
<span class="sd">    containing all of the :class:`ufl.measure.Measure` instances for </span>
<span class="sd">    this :class:`~model.Model`. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculate the number of cells and facets that are of a certain type</span>
    <span class="c1"># for determining Dirichlet boundaries :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_OMEGA_GND</span>   <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">OMEGA_GND</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_OMEGA_FLT</span>   <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cf</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">OMEGA_FLT</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_GND</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_GND</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_GND</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_GND</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_FLT</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_FLT</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_FLT</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_FLT</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_L_DVD</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_DVD</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_L_OVR</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_OVR</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_L_UDR</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_L_UDR</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_GND</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_GND</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_FLT</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="o">.</span><span class="n">array</span><span class="p">()</span>     <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_FLT</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_ACC</span>   <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ff_acc</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_ACC</span><span class="p">)</span>

    <span class="c1"># create new measures of integration :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ds</span>      <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;ds&#39;</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dx</span>      <span class="o">=</span> <span class="n">Measure</span><span class="p">(</span><span class="s1">&#39;dx&#39;</span><span class="p">,</span> <span class="n">subdomain_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cf</span><span class="p">)</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">dx_g</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                <span class="c1"># internal above grounded</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dx_f</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>                <span class="c1"># internal above floating</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dBed_g</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>                <span class="c1"># grounded bed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dBed_f</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                <span class="c1"># floating bed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dBed</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>   <span class="c1"># bed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf_gu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>                <span class="c1"># grounded with U observations</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf_fu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>                <span class="c1"># floating with U observations</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf_u</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>   <span class="c1"># surface with U observations</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf_g</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>   <span class="c1"># surface of grounded ice</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf_f</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>   <span class="c1"># surface of floating ice</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dSrf</span>    <span class="o">=</span>   <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> \
                   <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="c1"># surface</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dLat_d</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>                <span class="c1"># lateral divide</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dLat_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                <span class="c1"># lateral terminus overwater</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dLat_tu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>               <span class="c1"># lateral terminus underwater</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dLat_t</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># lateral terminus</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dLat</span>    <span class="o">=</span>   <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> \
                   <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>             <span class="c1"># lateral</span>
    
    <span class="bp">self</span><span class="o">.</span><span class="n">dOmega</span>     <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                      <span class="s1">&#39;entire interior&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dOmega_g</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                      <span class="s1">&#39;interior above grounded ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dOmega_w</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="s1">&#39;interior above floating ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma</span>     <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>
                      <span class="s1">&#39;entire exterior&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_bg</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                      <span class="s1">&#39;grounded basal surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_bw</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span>
                      <span class="s1">&#39;floating basal surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_b</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
                      <span class="s1">&#39;entire basal surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sgu</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">],</span>
                      <span class="s1">&#39;upper surface with U observations above grounded ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_swu</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span>
                      <span class="s1">&#39;upper surface with U observations above floating ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_su</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>
                      <span class="s1">&#39;entire upper surface with U observations&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sg</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span>
                      <span class="s1">&#39;upper surface above grounded ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sw</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>
                      <span class="s1">&#39;upper surface above floating ice&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_s</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span>
                      <span class="s1">&#39;entire upper surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_ld</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span>
                      <span class="s1">&#39;lateral interior surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_lto</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                      <span class="s1">&#39;exterior lateral surface above water&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_ltu</span> <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span>
                      <span class="s1">&#39;exterior lateral surface below= water&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_lt</span>  <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>
                      <span class="s1">&#39;entire exterior lateral surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_l</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span>
                      <span class="s1">&#39;entire exterior and interior lateral surface&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_w</span>   <span class="o">=</span> <span class="n">Boundary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ds</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
                      <span class="s1">&#39;exterior surface in contact with water&#39;</span><span class="p">)</span>

    <span class="c1"># save a dictionary of boundaries for later access by user :</span>
    <span class="n">measures</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dOmega</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dOmega_g</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dOmega_w</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_bg</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_bw</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_b</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sgu</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_swu</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_su</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sg</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_sw</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_s</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_ld</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_lto</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_ltu</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_lt</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dGamma_l</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">measures</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">measures</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">measures</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">description</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span></div>


<div class="viewcode-block" id="D3Model.deform_mesh_to_geometry"><a class="viewcode-back" href="../model.html#d3model.D3Model.deform_mesh_to_geometry">[docs]</a>  <span class="k">def</span> <span class="nf">deform_mesh_to_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deforms the 3D mesh to the geometry from FEniCS Expressions for the </span>
<span class="sd">    surface &lt;S&gt; and bed &lt;B&gt;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: deforming mesh to geometry :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># initialize the topography functions :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_S</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_B</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>

    <span class="c1"># convert constants to expressions that can be evaluated at (x,y,z) :</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="n">Constant</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">S</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">S</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="n">Constant</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">B</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># transform z :</span>
    <span class="c1"># thickness = surface - base, z = thickness + base</span>
    <span class="c1"># Get the height of the mesh, assumes that the base is at z=0</span>
    <span class="n">max_height</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">min_height</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">mesh_height</span> <span class="o">=</span> <span class="n">max_height</span> <span class="o">-</span> <span class="n">min_height</span>

    <span class="c1"># sigma coordinate :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_sigma</span><span class="p">(</span> <span class="n">project</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_height</span><span class="p">)</span> <span class="o">/</span> <span class="n">mesh_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">)</span> <span class="p">)</span>
    
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - iterating through </span><span class="si">%i</span><span class="s2"> vertices - &quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_vertices</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">():</span>
      <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">mesh_height</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
      <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;    - done - &quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>
      
<div class="viewcode-block" id="D3Model.calc_thickness"><a class="viewcode-back" href="../model.html#d3model.D3Model.calc_thickness">[docs]</a>  <span class="k">def</span> <span class="nf">calc_thickness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the continuous thickness field which increases from 0 at the </span>
<span class="sd">    surface to the actual thickness at the bed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: calculating z-varying thickness :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    <span class="c1">#H = project(self.S - self.x[2], self.Q, annotate=False)</span>
    <span class="n">H</span>          <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vert_integrate</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>
    <span class="n">Hv</span>         <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">Hv</span><span class="p">[</span><span class="n">Hv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">print_min_max</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span></div>
  
<div class="viewcode-block" id="D3Model.solve_hydrostatic_pressure"><a class="viewcode-back" href="../model.html#d3model.D3Model.solve_hydrostatic_pressure">[docs]</a>  <span class="k">def</span> <span class="nf">solve_hydrostatic_pressure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve for the hydrostatic pressure &#39;p&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="c1"># solve for vertical velocity :</span>
    <span class="n">s</span>  <span class="o">=</span> <span class="s2">&quot;::: solving hydrostatic pressure :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">rhoi</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhoi</span>
    <span class="n">g</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span>
    <span class="n">p</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vert_integrate</span><span class="p">(</span><span class="n">rhoi</span><span class="o">*</span><span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span>
    <span class="n">pv</span>     <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
    <span class="n">pv</span><span class="p">[</span><span class="n">pv</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span></div>
  
<div class="viewcode-block" id="D3Model.vert_extrude"><a class="viewcode-back" href="../model.html#d3model.D3Model.vert_extrude">[docs]</a>  <span class="k">def</span> <span class="nf">vert_extrude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This extrudes a function *u* vertically in the direction *d* = &#39;up&#39; or</span>
<span class="sd">    &#39;down&#39;.  It does this by solving a variational problem:</span>
<span class="sd">  </span>
<span class="sd">    .. math::</span>
<span class="sd">       </span>
<span class="sd">       \frac{\partial v}{\partial z} = 0 \hspace{10mm}</span>
<span class="sd">       v|_b = u</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: extruding function </span><span class="si">%s</span><span class="s2">wards :::&quot;</span> <span class="o">%</span> <span class="n">d</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FunctionSpace</span><span class="p">:</span>
      <span class="c1">#Q  = self.Q_non_periodic</span>
      <span class="n">Q</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">function_space</span><span class="p">()</span>
    <span class="n">ff</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span>
    <span class="n">phi</span>  <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">v</span>    <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">a</span>    <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">L</span>    <span class="o">=</span> <span class="n">DOLFIN_EPS</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">bcs</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># extrude bed (ff = 3,5) </span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
    <span class="c1"># extrude surface (ff = 2,6) </span>
    <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> extruded </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;extruded&#39;</span>
    <span class="n">v</span>    <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">,</span>
          <span class="n">solver_parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_solve_params</span><span class="p">())</span>
    <span class="n">print_min_max</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;extruded function&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span></div>
  
<div class="viewcode-block" id="D3Model.vert_integrate"><a class="viewcode-back" href="../model.html#d3model.D3Model.vert_integrate">[docs]</a>  <span class="k">def</span> <span class="nf">vert_integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate &lt;u&gt; from the bed to the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: vertically integrating function :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">!=</span> <span class="n">FunctionSpace</span><span class="p">:</span>
      <span class="n">Q</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q_non_periodic</span>
      <span class="c1">#Q = u.function_space()</span>
    <span class="n">ff</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ff</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">v</span>   <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
    <span class="n">bcs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># integral is zero on bed (ff = 3,5) </span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_B_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_B_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
      <span class="n">a</span>      <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="c1"># integral is zero on surface (ff = 2,6) </span>
    <span class="k">elif</span> <span class="n">d</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_S_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_S_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_GND</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_GND</span><span class="p">))</span>  <span class="c1"># grounded</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">N_GAMMA_U_FLT</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">GAMMA_U_FLT</span><span class="p">))</span>  <span class="c1"># shelves</span>
      <span class="n">a</span>      <span class="o">=</span> <span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">dx</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">L</span>      <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">phi</span> <span class="o">*</span> <span class="n">dx</span>
    <span class="n">name</span>   <span class="o">=</span> <span class="s1">&#39;value integrated </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span> 
    <span class="n">v</span>      <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">L</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">,</span>
          <span class="n">solver_parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">linear_solve_params</span><span class="p">())</span>
    <span class="n">print_min_max</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s1">&#39;vertically integrated function&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="D3Model.calc_vert_average"><a class="viewcode-back" href="../model.html#d3model.D3Model.calc_vert_average">[docs]</a>  <span class="k">def</span> <span class="nf">calc_vert_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the vertical average of a given function *u*.  </span>
<span class="sd">    </span>
<span class="sd">    :param u: Function to avergage vertically</span>
<span class="sd">    :rtype:   the vertical average of *u*</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: calculating vertical average :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># vertically integrate the function up and then extrude that down :</span>
    <span class="n">ubar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vert_integrate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span>  <span class="n">d</span><span class="o">=</span><span class="s1">&#39;up&#39;</span><span class="p">,</span>   <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span>
    <span class="n">ubar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vert_extrude</span><span class="p">(</span><span class="n">ubar</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="s1">&#39;down&#39;</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;vertical average of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">u</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;vertical average&#39;</span>
    <span class="n">ubar</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
   
    <span class="c1"># divide by the thickness for vertical average : </span>
    <span class="n">ubar_v</span> <span class="o">=</span> <span class="n">ubar</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">S_v</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">B_v</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">H_v</span>    <span class="o">=</span> <span class="n">S_v</span> <span class="o">-</span> <span class="n">B_v</span> <span class="o">+</span> <span class="n">DOLFIN_EPS</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="n">ubar</span><span class="p">,</span> <span class="n">ubar_v</span> <span class="o">/</span> <span class="n">H_v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ubar</span></div>
 
<div class="viewcode-block" id="D3Model.save_bed_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.save_bed_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">save_bed_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5File</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    save the basal boundary mesh to hdf5 file &lt;h5File&gt;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: writing &#39;bedmesh&#39; to supplied hdf5 file :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="n">h5File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bedmesh</span><span class="p">,</span> <span class="s1">&#39;bedmesh&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.save_srf_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.save_srf_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">save_srf_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5File</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    save the surface boundary mesh to hdf5 file &lt;h5File&gt;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: writing &#39;srfmesh&#39; to supplied hdf5 file :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="n">h5File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">srfmesh</span><span class="p">,</span> <span class="s1">&#39;srfmesh&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.save_lat_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.save_lat_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">save_lat_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5File</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    save the lateral boundary mesh to hdf5 file &lt;h5File&gt;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: writing &#39;latmesh&#39; to supplied hdf5 file :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="n">h5File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latmesh</span><span class="p">,</span> <span class="s1">&#39;latmesh&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.save_dvd_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.save_dvd_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">save_dvd_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h5File</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    save the divide boundary mesh to hdf5 file &lt;h5File&gt;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: writing &#39;dvdmesh&#39; to supplied hdf5 file :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="n">h5File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dvdmesh</span><span class="p">,</span> <span class="s1">&#39;dvdmesh&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.initialize_variables"><a class="viewcode-back" href="../model.html#d3model.D3Model.initialize_variables">[docs]</a>  <span class="k">def</span> <span class="nf">initialize_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializes the class&#39;s variables to default values that are then set</span>
<span class="sd">    by the individually created model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">(</span><span class="n">D3Model</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">initialize_variables</span><span class="p">()</span>

    <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;::: initializing 3D variables :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># Depth below sea level :</span>
    <span class="k">class</span> <span class="nc">Depth</span><span class="p">(</span><span class="n">Expression</span><span class="p">):</span>
      <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">D</span> <span class="o">=</span> <span class="n">Depth</span><span class="p">(</span><span class="n">element</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="o">.</span><span class="n">ufl_element</span><span class="p">())</span>
    
    <span class="c1"># age  :  </span>
    <span class="bp">self</span><span class="o">.</span><span class="n">age</span>           <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;age&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">a0</span>            <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;a0&#39;</span><span class="p">)</span>

    <span class="c1"># mass :    </span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mhat</span>          <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;mhat&#39;</span><span class="p">)</span>  <span class="c1"># mesh velocity</span>

    <span class="c1"># specical dof mapping for periodic spaces :</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_periodic</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">mhat_non</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q_non_periodic</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assmhat</span>  <span class="o">=</span> <span class="n">FunctionAssigner</span><span class="p">(</span><span class="n">mhat</span><span class="o">.</span><span class="n">function_space</span><span class="p">(),</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">Q_non_periodic</span><span class="p">)</span>

    <span class="c1"># surface climate :</span>
    <span class="c1"># TODO: re-implent this (it was taken out somewhere)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">precip</span>        <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;precip&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.thermo_solve"><a class="viewcode-back" href="../model.html#d3model.D3Model.thermo_solve">[docs]</a>  <span class="k">def</span> <span class="nf">thermo_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">energy</span><span class="p">,</span> <span class="n">wop_kwargs</span><span class="p">,</span>
                   <span class="n">callback</span>           <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">atol</span>               <span class="o">=</span> <span class="mf">1e2</span><span class="p">,</span>
                   <span class="n">rtol</span>               <span class="o">=</span> <span class="mf">1e0</span><span class="p">,</span>
                   <span class="n">max_iter</span>           <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                   <span class="n">iter_save_vars</span>     <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">post_tmc_save_vars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">starting_i</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Perform thermo-mechanical coupling between momentum and energy.</span>

<span class="sd">    :param momentum:       momentum instance to couple with ``energy``.</span>
<span class="sd">    :param energy:         energy instance to couple with ``momentum``.</span>
<span class="sd">                           Currently, the only 3D energy implementation is </span>
<span class="sd">                           :class:`~energy.Enthalpy`.</span>
<span class="sd">    :param wop_kwargs:     a :py:class:`~dict` of arguments for</span>
<span class="sd">                           water-optimization method </span>
<span class="sd">                           :func:`~energy.Energy.optimize_water_flux`</span>
<span class="sd">    :param callback:       a function that is called back at the end of each </span>
<span class="sd">                           iteration</span>
<span class="sd">    :param atol:           absolute stopping tolerance </span>
<span class="sd">                           :math:`a_{tol} \leq r = \Vert \theta_n - \theta_{n-1} \Vert`</span>
<span class="sd">    :param rtol:           relative stopping tolerance</span>
<span class="sd">                           :math:`r_{tol} \leq \Vert r_n - r_{n-1} \Vert`</span>
<span class="sd">    :param max_iter:       maximum number of iterations to perform</span>
<span class="sd">    :param iter_save_vars: python :py:class:`~list` containing functions to </span>
<span class="sd">                           save each iteration</span>
<span class="sd">    :param starting_i:     if you are restarting this process, you may start </span>
<span class="sd">                           it at a later iteration. </span>
<span class="sd">    </span>
<span class="sd">    :type momentum:        :class:`~momentum.Momentum`</span>
<span class="sd">    :type energy:          :class:`~energy.Energy`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span>    <span class="o">=</span> <span class="s1">&#39;::: performing thermo-mechanical coupling with atol = </span><span class="si">%.2e</span><span class="s1">, &#39;</span> <span class="o">+</span> \
           <span class="s1">&#39;rtol = </span><span class="si">%.2e</span><span class="s1">, and max_iter = </span><span class="si">%i</span><span class="s1"> :::&#39;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span> <span class="o">%</span> <span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">),</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    
    <span class="kn">from</span> <span class="nn">cslvr</span> <span class="k">import</span> <span class="n">Momentum</span>
    <span class="kn">from</span> <span class="nn">cslvr</span> <span class="k">import</span> <span class="n">Energy</span>

    <span class="c1"># TODO: also make sure these are D3Model momentum and energy classes. </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">momentum</span><span class="p">,</span> <span class="n">Momentum</span><span class="p">):</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt; thermo_solve REQUIRES A &#39;Momentum&#39; INSTANCE, NOT </span><span class="si">%s</span><span class="s2"> &lt;&lt;&lt;&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">momentum</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">Energy</span><span class="p">):</span>
      <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt; thermo_solve REQUIRES AN &#39;Energy&#39; INSTANCE, NOT </span><span class="si">%s</span><span class="s2"> &lt;&lt;&lt;&quot;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span> <span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># mark starting time :</span>
    <span class="n">t0</span>   <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

    <span class="c1"># ensure that we have a steady-state form :</span>
    <span class="k">if</span> <span class="n">energy</span><span class="o">.</span><span class="n">transient</span><span class="p">:</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">make_steady_state</span><span class="p">()</span>

    <span class="c1"># retain base install directory :</span>
    <span class="n">out_dir_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span>

    <span class="c1"># directory for saving convergence history :</span>
    <span class="n">d_hist</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">+</span> <span class="s1">&#39;tmc/convergence_history/&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">d_hist</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">d_hist</span><span class="p">)</span>

    <span class="c1"># number of digits for saving variables :</span>
    <span class="n">n_i</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">max_iter</span><span class="p">))</span>
    
    <span class="c1"># get the bounds of Fb, the max will be updated based on temperate zones :</span>
    <span class="k">if</span> <span class="n">energy</span><span class="o">.</span><span class="n">energy_flux_mode</span> <span class="o">==</span> <span class="s1">&#39;Fb&#39;</span><span class="p">:</span>
      <span class="n">bounds</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">wop_kwargs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">])</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">init_Fb_min</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">init_Fb_max</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="n">wop_kwargs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Fb_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fb_max</span><span class="p">)</span>

    <span class="c1"># L_2 erro norm between iterations :</span>
    <span class="n">abs_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">rel_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
      
    <span class="c1"># number of iterations, from a starting point (useful for restarts) :</span>
    <span class="k">if</span> <span class="n">starting_i</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="n">starting_i</span>
   
    <span class="c1"># previous velocity for norm calculation</span>
    <span class="n">U_prev</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># perform a fixed-point iteration until the L_2 norm of error </span>
    <span class="c1"># is less than tolerance :</span>
    <span class="k">while</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">atol</span> <span class="ow">and</span> <span class="n">rel_error</span> <span class="o">&gt;</span> <span class="n">rtol</span> <span class="ow">and</span> <span class="n">counter</span> <span class="o">&lt;=</span> <span class="n">max_iter</span><span class="p">:</span>
       
      <span class="c1"># set a new unique output directory :</span>
      <span class="n">out_dir_n</span> <span class="o">=</span> <span class="s1">&#39;tmc/</span><span class="si">%0*d</span><span class="s1">/&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_i</span><span class="p">,</span> <span class="n">counter</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">set_out_dir</span><span class="p">(</span><span class="n">out_dir_i</span> <span class="o">+</span> <span class="n">out_dir_n</span><span class="p">)</span>
      
      <span class="c1"># solve velocity :</span>
      <span class="n">momentum</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

      <span class="c1"># update pressure-melting point :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">calc_T_melt</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

      <span class="c1"># calculate basal friction heat flux :</span>
      <span class="n">momentum</span><span class="o">.</span><span class="n">calc_q_fric</span><span class="p">()</span>
      
      <span class="c1"># derive temperature and temperature-melting flux terms :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">calc_basal_temperature_flux</span><span class="p">()</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">calc_basal_temperature_melting_flux</span><span class="p">()</span>

      <span class="c1"># solve energy steady-state equations to derive temperate zone :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">derive_temperate_zone</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      
      <span class="c1"># fixed-point interation for thermal parameters and discontinuous </span>
      <span class="c1"># properties :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">update_thermal_parameters</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      
      <span class="c1"># calculate the basal-melting rate :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">solve_basal_melt_rate</span><span class="p">()</span>
      
      <span class="c1"># always initialize Fb to the zero-energy-flux bc :  </span>
      <span class="n">Fb_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Mb</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhoi</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhow</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">init_Fb</span><span class="p">(</span><span class="n">Fb_v</span><span class="p">)</span>
  
      <span class="c1"># update bounds based on temperate zone :</span>
      <span class="k">if</span> <span class="n">energy</span><span class="o">.</span><span class="n">energy_flux_mode</span> <span class="o">==</span> <span class="s1">&#39;Fb&#39;</span><span class="p">:</span>
        <span class="n">Fb_m_v</span>                 <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Fb_max</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
        <span class="n">alpha_v</span>                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
        <span class="n">Fb_m_v</span><span class="p">[:]</span>              <span class="o">=</span> <span class="n">DOLFIN_EPS</span>
        <span class="n">Fb_m_v</span><span class="p">[</span><span class="n">alpha_v</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_Fb_max</span><span class="p">(</span><span class="n">Fb_m_v</span><span class="p">)</span>
      
      <span class="c1"># optimize the flux of water to remove abnormally high water :</span>
      <span class="k">if</span> <span class="n">energy</span><span class="o">.</span><span class="n">energy_flux_mode</span> <span class="o">==</span> <span class="s1">&#39;Fb&#39;</span><span class="p">:</span>
        <span class="n">energy</span><span class="o">.</span><span class="n">optimize_water_flux</span><span class="p">(</span><span class="o">**</span><span class="n">wop_kwargs</span><span class="p">)</span>

      <span class="c1"># solve the energy-balance and partition T and W from theta :</span>
      <span class="n">energy</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">annotate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
      
      <span class="c1"># calculate L_2 norms :</span>
      <span class="n">abs_error_n</span>  <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">U_prev</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="s1">&#39;l2&#39;</span><span class="p">)</span>
      <span class="n">tht_nrm</span>      <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="s1">&#39;l2&#39;</span><span class="p">)</span>

      <span class="c1"># save convergence history :</span>
      <span class="k">if</span> <span class="n">counter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">rel_error</span>  <span class="o">=</span> <span class="n">abs_error_n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">err_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abs_error_n</span><span class="p">])</span>
          <span class="n">nrm_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tht_nrm</span><span class="p">])</span>
          <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;abs_err.txt&#39;</span><span class="p">,</span>    <span class="n">err_a</span><span class="p">)</span>
          <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;theta_norm.txt&#39;</span><span class="p">,</span> <span class="n">nrm_a</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">rel_error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">abs_error</span> <span class="o">-</span> <span class="n">abs_error_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">err_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;abs_err.txt&#39;</span><span class="p">)</span>
          <span class="n">nrm_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;theta_norm.txt&#39;</span><span class="p">)</span>
          <span class="n">err_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err_n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">abs_error_n</span><span class="p">]))</span>
          <span class="n">nrm_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nrm_n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tht_nrm</span><span class="p">]))</span>
          <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;abs_err.txt&#39;</span><span class="p">,</span>     <span class="n">err_a</span><span class="p">)</span>
          <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;theta_norm.txt&#39;</span><span class="p">,</span>  <span class="n">nrm_a</span><span class="p">)</span>

      <span class="c1"># print info to screen :</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s0</span>    <span class="o">=</span> <span class="s1">&#39;&gt;&gt;&gt; &#39;</span>
        <span class="n">s1</span>    <span class="o">=</span> <span class="s1">&#39;TMC fixed-point iteration </span><span class="si">%i</span><span class="s1"> (max </span><span class="si">%i</span><span class="s1">) done: &#39;</span> \
                 <span class="o">%</span> <span class="p">(</span><span class="n">counter</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">)</span>
        <span class="n">s2</span>    <span class="o">=</span> <span class="s1">&#39;r (abs) = </span><span class="si">%.2e</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">abs_error</span>
        <span class="n">s3</span>    <span class="o">=</span> <span class="s1">&#39;(tol </span><span class="si">%.2e</span><span class="s1">), &#39;</span>    <span class="o">%</span> <span class="n">atol</span>
        <span class="n">s4</span>    <span class="o">=</span> <span class="s1">&#39;r (rel) = </span><span class="si">%.2e</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">rel_error</span>
        <span class="n">s5</span>    <span class="o">=</span> <span class="s1">&#39;(tol </span><span class="si">%.2e</span><span class="s1">)&#39;</span>      <span class="o">%</span> <span class="n">rtol</span>
        <span class="n">s6</span>    <span class="o">=</span> <span class="s1">&#39; &lt;&lt;&lt;&#39;</span>
        <span class="n">text0</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">text1</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">text2</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">text3</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s3</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">text4</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s4</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">text5</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s5</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">text6</span> <span class="o">=</span> <span class="n">get_text</span><span class="p">(</span><span class="n">s6</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span> <span class="n">text0</span> <span class="o">+</span> <span class="n">text1</span> <span class="o">+</span> <span class="n">text2</span> <span class="o">+</span> <span class="n">text3</span> <span class="o">+</span> <span class="n">text4</span> <span class="o">+</span> <span class="n">text5</span> <span class="o">+</span> <span class="n">text6</span>

      <span class="c1"># call callback function if set :</span>
      <span class="k">if</span> <span class="n">callback</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">s</span>    <span class="o">=</span> <span class="s1">&#39;::: calling thermo-couple-callback function :::&#39;</span>
        <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
        <span class="n">callback</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
    
      <span class="c1"># save state to unique hdf5 file :</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter_save_vars</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">s</span>    <span class="o">=</span> <span class="s1">&#39;::: saving variables in list arg iter_save_vars :::&#39;</span>
        <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
        <span class="n">out_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">+</span> <span class="s1">&#39;tmc.h5&#39;</span>
        <span class="n">foutput</span>  <span class="o">=</span> <span class="n">HDF5File</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="n">out_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">iter_save_vars</span><span class="p">:</span>
          <span class="bp">self</span><span class="o">.</span><span class="n">save_hdf5</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">foutput</span><span class="p">)</span>
        <span class="n">foutput</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
      
      <span class="c1"># update error stuff and increment iteration counter :</span>
      <span class="n">abs_error</span>    <span class="o">=</span> <span class="n">abs_error_n</span>
      <span class="n">U_prev</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">counter</span>     <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># reset the base directory ! :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">set_out_dir</span><span class="p">(</span><span class="n">out_dir_i</span><span class="p">)</span>
    
    <span class="c1"># reset the bounds on Fb :</span>
    <span class="k">if</span> <span class="n">energy</span><span class="o">.</span><span class="n">energy_flux_mode</span> <span class="o">==</span> <span class="s1">&#39;Fb&#39;</span><span class="p">:</span>  <span class="n">wop_kwargs</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
      
    <span class="c1"># save state to unique hdf5 file :</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">post_tmc_save_vars</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="n">s</span>    <span class="o">=</span> <span class="s1">&#39;::: saving variables in list arg post_tmc_save_vars :::&#39;</span>
      <span class="n">print_text</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
      <span class="n">out_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">+</span> <span class="s1">&#39;tmc.h5&#39;</span>
      <span class="n">foutput</span>  <span class="o">=</span> <span class="n">HDF5File</span><span class="p">(</span><span class="n">mpi_comm_world</span><span class="p">(),</span> <span class="n">out_file</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">post_tmc_save_vars</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_hdf5</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">foutput</span><span class="p">)</span>
      <span class="n">foutput</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># calculate total time to compute</span>
    <span class="n">tf</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="n">s</span>  <span class="o">=</span> <span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span>
    <span class="n">m</span>  <span class="o">=</span> <span class="n">s</span> <span class="o">/</span> <span class="mf">60.0</span>
    <span class="n">h</span>  <span class="o">=</span> <span class="n">m</span> <span class="o">/</span> <span class="mf">60.0</span>
    <span class="n">s</span>  <span class="o">=</span> <span class="n">s</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="n">m</span>  <span class="o">=</span> <span class="n">m</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;time to thermo-couple: </span><span class="si">%02d</span><span class="s2">:</span><span class="si">%02d</span><span class="s2">:</span><span class="si">%02d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
       
    <span class="c1"># plot the convergence history : </span>
    <span class="n">s</span>    <span class="o">=</span> <span class="s2">&quot;::: convergence info saved to </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s2"> :::&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="n">s</span> <span class="o">%</span> <span class="n">d_hist</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MPI_rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;time.txt&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tf</span> <span class="o">-</span> <span class="n">t0</span><span class="p">]))</span>

      <span class="n">err_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;abs_err.txt&#39;</span><span class="p">)</span>
      <span class="n">nrm_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;theta_norm.txt&#39;</span><span class="p">)</span>
     
      <span class="c1"># plot iteration error : </span>
      <span class="n">fig</span>   <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
      <span class="n">ax</span>    <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\Vert \theta_{n-1} - \theta_n \Vert$&#39;</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">err_a</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;abs_err.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
      
      <span class="c1"># plot theta norm :</span>
      <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
      <span class="n">ax</span>  <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\Vert \theta_n \Vert$&#39;</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
      <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nrm_a</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">d_hist</span> <span class="o">+</span> <span class="s1">&#39;theta_norm.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="D3Model.update_mesh"><a class="viewcode-back" href="../model.html#d3model.D3Model.update_mesh">[docs]</a>  <span class="k">def</span> <span class="nf">update_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This method will update the surface height ``self.S`` and vertices </span>
<span class="sd">    of deformed mesh ``self.mesh``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">print_text</span><span class="p">(</span><span class="s2">&quot;    - updating mesh -&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
    
    <span class="c1"># update the mesh :</span>
    <span class="n">sigma</span>                        <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
    <span class="n">S</span>                            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
    <span class="n">B</span>                            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">compute_vertex_values</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">()[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigma</span><span class="o">*</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span> <span class="o">+</span> <span class="n">B</span>  <span class="c1"># only the z coordinate </span></div>

<div class="viewcode-block" id="D3Model.transient_iteration"><a class="viewcode-back" href="../model.html#d3model.D3Model.transient_iteration">[docs]</a>  <span class="k">def</span> <span class="nf">transient_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">momentum</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">adaptive</span><span class="p">,</span> <span class="n">annotate</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function defines one interation of the transient solution, and is </span>
<span class="sd">    called by the function :func:`~model.transient_solve`.</span>

<span class="sd">    Currently, the dolfin-adjoint ``annotate`` is not supported.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span>        <span class="o">=</span> <span class="n">time_step</span>
    <span class="n">mesh</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
    <span class="n">dSdt</span>      <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dSdt</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
      <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">init_S</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
      <span class="n">mass</span><span class="o">.</span><span class="n">solve_dSdt</span><span class="p">()</span>
      <span class="k">return</span> <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">dSdt</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>

    <span class="c1"># calculate velocity :</span>
    <span class="n">momentum</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

    <span class="c1"># update the mass model&#39;s velocity field :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_to_submesh_variable</span><span class="p">(</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">U3</span><span class="p">,</span>   <span class="n">u_sub</span> <span class="o">=</span> <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">U3</span><span class="p">)</span>

    <span class="c1"># save the initial surface :</span>
    <span class="n">S_0</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>

    <span class="c1"># calculate new surface :</span>
    <span class="c1">#mass.solve()</span>

    <span class="c1"># impose the thickness limit and update the model&#39;s surface :</span>
    <span class="n">S_a</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">RK4</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">(),</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">B_a</span>         <span class="o">=</span> <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">thin</span>        <span class="o">=</span> <span class="p">(</span><span class="n">S_a</span> <span class="o">-</span> <span class="n">B_a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mass</span><span class="o">.</span><span class="n">thklim</span>
    <span class="n">S_a</span><span class="p">[</span><span class="n">thin</span><span class="p">]</span>   <span class="o">=</span> <span class="n">B_a</span><span class="p">[</span><span class="n">thin</span><span class="p">]</span> <span class="o">+</span> <span class="n">mass</span><span class="o">.</span><span class="n">thklim</span>
    <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">init_S</span><span class="p">(</span><span class="n">S_a</span><span class="p">)</span>

    <span class="c1"># update the 3D model&#39;s surface :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assign_from_submesh_variable</span><span class="p">(</span><span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="p">,</span>  <span class="n">u_sub</span> <span class="o">=</span> <span class="n">mass</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>

    <span class="c1"># save the new surface :</span>
    <span class="n">S_1</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">S</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>

    <span class="c1"># deform the mesh :</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_mesh</span><span class="p">()</span>

    <span class="c1"># calculate mesh velocity :</span>
    <span class="n">sigma_a</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
    <span class="n">mhat_a</span>    <span class="o">=</span> <span class="p">(</span><span class="n">S_1</span> <span class="o">-</span> <span class="n">S_0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">sigma_a</span>

    <span class="c1"># set mesh velocity depending on periodicity due to the fact that </span>
    <span class="c1"># the topography S and B are always not periodic :</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_periodic</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mhat_non</span><span class="p">,</span> <span class="n">mhat_a</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assmhat</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mhat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mhat_non</span><span class="p">,</span> <span class="n">annotate</span><span class="o">=</span><span class="n">annotate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">assign_variable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mhat</span><span class="p">,</span> <span class="n">mhat_a</span><span class="p">)</span></div></div>



</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Evan M. Cummings.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>