"""

EISMINT model intercomparison:

http://homepages.vub.ac.be/~phuybrec/eismint.html

Solves the thermo-mechanically-coupled three-dimensional model and 
upper-free-surface equation.

Written by Evan Cummings in his free time during May, 2018.

"""

from cslvr import *

# directories for loading or saving data :
msh_dir = './meshes/'  # directory where the mesh is located
out_dir = './A/'       # directory to save results
mdl_odr = 'BP'         # the order of the momentum model

thklim  = 1.0          # [m] thickness limit
L       = 800000.0     # [m] mesh radius
Rel     = 450000       # [m] radial distance at which adot becomes negative
s       = 1e-5         # [a^{-1}] accumulation/ablation coefficient
Tmin    = 238.15       # [K] minimum temperature (located at divide)
St      = 1.67e-5      # [K m^{-1}] lapse rate

# load the mesh that was generated by gen_cylinder.py :
mesh    = Mesh(msh_dir + 'cylinder_mesh.xml.gz')

# these are the mesh attributes which we use to deform :
xmin    = -L
xmax    =  L
ymin    = -L
ymax    =  L

# width and origin of the domain for deforming x coord :
width_x  = xmax - xmin
offset_x = xmin

# width and origin of the domain for deforming y coord :
width_y  = ymax - ymin
offset_y = ymin

# iterate through the mesh coordinates and alter the horizontal components :
for x in mesh.coordinates():
  x[0]  = x[0]  * width_x           # transform x
  x[1]  = x[1]  * width_y           # transform y

# initialize the model :
model = D3Model(mesh, out_dir=out_dir, use_periodic=False)

# form the 2D upper-surface mesh :
model.form_srf_mesh()

# form a 2D model using the upper-surface mesh :
srfmodel = D2Model(model.srfmesh,
                   out_dir      = out_dir,
                   use_periodic = False,
                   kind         = 'submesh')

# generate the map between the 3D and 2D models : 
model.generate_submesh_to_mesh_map(sub_model=srfmodel)

# set the model geometry and deform the mesh z coordinate to match :
model.deform_mesh_to_geometry(S=thklim, B=0)

# iterate through and color each facet and cell of the mesh :
model.calculate_boundaries()

# define the surface mass balance : 
class Adot(Expression):
  def eval(self, values, x):
    values[0] = min(0.5, s * (Rel - sqrt(x[0]**2 + x[1]**2)))
adot = Adot(element=model.Q.ufl_element())

# define the surface temperature :
class SurfaceTemperature(Expression):
  def eval(self, values, x):
    values[0] = Tmin + St * sqrt(x[0]**2 + x[1]**2)
T_s = SurfaceTemperature(element=model.Q.ufl_element())

# initialize the 3D model variables :
model.init_adot(adot)           # upper surface-mass balance
model.init_T_surface(T_s)       # upper surface temperature
model.init_T(T_s)               # initial 3D temperature
model.init_q_geo(model.ghf)     # geothermal heat flux
model.init_E(1.0)               # flow enhancement (1.0 == no enhancement)
model.init_W(0.0)               # water content (0.0 == no water)
model.init_k_0(1e-3)            # water "non-advective" coefficient (enthalpy)
model.init_beta(1e9)            # basal fricition coefficient
#model.init_beta_stats()     
model.init_A(1e-16)             # constant flow-rate factor
#model.solve_hydrostatic_pressure()
#model.form_energy_dependent_rate_factor()

# update the 2D model variables that we'll need to compute the mass balance :
model.assign_to_submesh_variable(u = model.S,      u_sub = srfmodel.S)
model.assign_to_submesh_variable(u = model.B,      u_sub = srfmodel.B)
model.assign_to_submesh_variable(u = model.adot,   u_sub = srfmodel.adot)

# we can choose any of these to solve our 3D-momentum problem :
if mdl_odr == 'BP':
  mom = MomentumBP(model, use_pressure_bc=False)
elif mdl_odr == 'BP_duk':
  mom = MomentumDukowiczBP(model, use_pressure_bc=False)
elif mdl_odr == 'RS':
  mom = MomentumDukowiczStokesReduced(model, use_pressure_bc=False)
elif mdl_odr == 'FS_duk':
  mom = MomentumDukowiczStokes(model, use_pressure_bc=False)
elif mdl_odr == 'FS_stab':
  mom = MomentumNitscheStokes(model, use_pressure_bc=False, stabilized=True)
elif mdl_odr == 'FS_th':
  mom = MomentumNitscheStokes(model, use_pressure_bc=False, stabilized=False)

mom.solve_params['solver']['newton_solver']['relaxation_parameter'] = 0.7

#nrg = Enthalpy(model, mom,
#               transient  = True,
#               use_lat_bc = False)
mass = UpperFreeSurface(srfmodel,
                        thklim              = thklim,
                        lump_mass_matrix    = False)

# create a function to be called at the end of each iteration :
U_file  = XDMFFile(out_dir + 'U.xdmf')
p_file  = XDMFFile(out_dir + 'p.xdmf')
S_file  = XDMFFile(out_dir + 'S.xdmf')
dS_file = XDMFFile(out_dir + 'dSdt.xdmf')
#T_file  = XDMFFile(out_dir + 'T.xdmf')

def cb_ftn(t):
  #nrg.solve()                               # quasi-thermo-mechanical couple
  model.save_xdmf(model.U3,         'U3',    f = U_file,  t = t)
  model.save_xdmf(model.p,          'p',     f = p_file,  t = t)
  srfmodel.save_xdmf(srfmodel.S,    'S',     f = S_file,  t = t)
  srfmodel.save_xdmf(srfmodel.dSdt, 'dSdt',  f = dS_file, t = t)
  #model.save_xdmf(model.T,  'T',  f = T_file)

# run the transient simulation :
model.transient_solve(mom, mass,
                      t_start    = 0.0,
                      t_end      = 10000.0,
                      time_step  = 10.0,
                      tmc_kwargs = None,
                      adaptive   = False,
                      annotate   = False,
                      callback   = cb_ftn)

U_file.close()
p_file.close()
S_file.close()
dS_file.close()



